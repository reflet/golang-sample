package main

import (
    "fmt"
    "runtime"
    "time"
)

/**
 * -------------------------------------------------------
 * 14.4 ゴルーチンとOSスレッド
 * -------------------------------------------------------
 */
func main() {
    // 14.4.1 OSスレッドの最大数(GOMAXPROCS)
    example41()

    // 14.4.2 ゴルーチンのスケジューラ
    example42()
}

/**
 * -------------------------------------------------------
 * 14.4.1 OSスレッドの最大数(GOMAXPROCS)
 * -------------------------------------------------------
 * ※ 2つのOSスレッドを使用したことによって、２つの論理CPUで計算され、実行時間が半分になる
 * ※ 論理CPUが1つの場合には、実行する環境次第では実行時間が同じになることもある
 */

// ループ回数
const c = 10000000

// 時間のかかるループ処理
func funcGoLoop(ch chan<- int) {
    n := 0
    for i := 0; i < c; i++ {
        n += i
    }
    ch <- n // 処理が終了したことを知らせる
}

// 時間のかかる2つのゴルーチンを実行
func funcGo() {
    ch := make(chan int) // 待ち合わせ用のチャンネル

    // 2つのゴルーチンを実行することで
    // 可能であればOSスレッドを2つ使用する
    go funcGoLoop(ch)
    go funcGoLoop(ch)

    // 2つのゴルーチンが終了するまで待つ
    <-ch
    <-ch
}

func example41() {
    // 使用するOSスレッドの最大数を「1」に設定
    runtime.GOMAXPROCS(1)
    t1 := time.Now()       // 現在の時刻を取得
    funcGo()
    fmt.Println("GOMAXPROCS=1:", time.Since(t1)) // 処理時間を出力

    // 使用するOSスレッドの最大数を「2」に設定
    runtime.GOMAXPROCS(2)
    t2 := time.Now()       // 現在の時刻を取得
    funcGo()
    fmt.Println("GOMAXPROCS=2:", time.Since(t2)) // 処理時間を出力
}

/**
 * -------------------------------------------------------
 * 14.4.2 ゴルーチンのスケジューラ
 * -------------------------------------------------------
 * ※ ゴルーチンの個数がOSスレッドの個数を超えた場合、厳密に言うと、すべてのゴルーチンを同時には実行しない
 * ※ 1つのOSスレッドで実行可能なのは、1つのゴルーチンとなる
 * ※ ゴルーチンのスケジューラがOSスレッドを使いますことで、
 * ※ スレジューラは、関数呼び出しやチャンネルの送受信などのタイミングでゴルーチンを切り替える
 *    つまり、これらのタイミングがなければ同じゴルーチンを実行し続ける
 *    そのため、無限ループのような処理は、ゴルーチンがOSスレッドを専有し続ける
 *    無限ループで関数呼び出しをしても、コンパイラの最適化（インライン関数化）次第で切り替わらないこともある
 * ※ 確実に切り替わるタイミングを作成したい場合は、runtimeパッケージのGosched関数を使う
 *    (Sosched関数を呼び出すと他のゴルーチンが実行される)
 * ※ runtime.Gosched関数でゴルーチンを切り替える場合、別のOSスレッドで実行される場合があります。
 *    外部ライブラリの関係などで常に同じOSスレッドを使いたい場合、runtime.LockOSThread関数で固定することができる
 */

// ゴルーチンがOSスレッドを専有する例
func example42() {
    // 使用するOSスレッドを1つにする
    runtime.GOMAXPROCS(1)

    // ゴルーチン実行
    go func() {
        fmt.Println("go")

        // 無限ループ。mainゴルーチンに切り替わらない
        i := 0
        for {
            // Gosched関数を呼び出すと、ゴルーチンが切り替わる
            // runtime.Gosched()
            i += 0
        }
    }()

    // mainゴルーチンの処理
    time.Sleep(time.Millisecond) // 1ミリ秒待つ
    fmt.Println("main")          // 実行されない
}
