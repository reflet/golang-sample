package main

import (
    "fmt"
    "time"
)

func main () {
    // 11.2.1 マップの型とリテラル
    example21()

    // 11.2.2 キーの確認方法
    example22()

    // 11.2.3 キーの削除
    example23()

    // 11.2.4 マップのmake関数
    example24()

    // 11.2.5 マップリテラルの省略記法
    example25()

    // 11.2.6 マップのfor文
    example26()
}

/**
 * -------------------------------------------------------
 * 11.2.1 マップの型とリテラル
 * -------------------------------------------------------
 */
func example21() {
    // マップ型変数の宣言（マップリテラル使用）
    map1 := map[string]int{"a": 1, "b": 2}

    // マップの要素の代入
    map1["a"], map1["c"] = 3, 4
    fmt.Println("len(map1):", len(map1))
    fmt.Println("map1:", map1["a"], map1["b"], map1["c"], map1["d"])

    // マップの代入
    map2 := map1
    map1["e"] = 5  // マップは参照型のため、map2の要素も更新される
    fmt.Println("map2:", map2["a"], map2["b"], map2["c"], map2["d"], map2["e"])

    // マップ型変数の宣言（初期値なし）
    var map3 map[string]int
    fmt.Println("map3:", map3["a"]) // nilマップの要素は、常にゼロ値
    // map3["a"] = 1                // <- nilマップの要素に代入するとエラー
}

/**
 * -------------------------------------------------------
 * 11.2.2 キーの確認方法
 * -------------------------------------------------------
 */
func example22() {
    // キーが存在する場合
    n, ok := map1["a"]
    fmt.Println(n, ok)

    // キーが存在しない場合
    n, ok = map1["f"]
    fmt.Println(n, ok)
}

/**
 * -------------------------------------------------------
 * 11.2.3 キーの削除
 * -------------------------------------------------------
 */
func example23() {
    // マップからキー"a"を削除する
    delete(map1, "a")

    // マップにキー"a"が存在しないため、変数okはfalseとなる
    n, ok = map1["a"]
    fmt.Println(n, ok)
}

/**
 * -------------------------------------------------------
 * 11.2.4 マップのmake関数
 * -------------------------------------------------------
 * make(マップ型)
 * make(マップ型, 要素の数)
 */

// ループ回数
const c = 100000

// マップにキーと要素を設定するループ処理
func funcMapLoop(m map[int]int) {
    for n := 0; n < c; n++ {
        m[n] = 1
    }
}

func example24() {
    // 要素の数を指定しないmake関数
    t41 := time.Now()                      // 現在時刻を取得 (time.Now: 現在時刻を取得)
    map41 := make(map[int]int)             // 要素の数を指定しない
    funcMapLoop(map41)                     // マップにキーと要素を設定
    fmt.Println("map41:", time.Since(t41)) // 処理時間を出力 (time.since: 指定時刻と現在時刻との差分を取得)

    // 要素の数を指定するmake関数
    t42 := time.Now()                      // 現在時刻を取得 (time.Now: 現在時刻を取得)
    map42 := make(map[int]int, c)          // 要素の数を指定しない
    funcMapLoop(map42)                     // マップにキーと要素を設定
    fmt.Println("map42:", time.Since(t42)) // 処理時間を出力 (time.since: 指定時刻と現在時刻との差分を取得)
}

/**
 * -------------------------------------------------------
 * 11.2.5 マップリテラルの省略記法
 * -------------------------------------------------------
 */
func example25() {
    type myStruct struct {
        s string
        x int
    }

    // キーの構造体に省略記法を使用する
    map51 := map[myStruct]int {
        {"A", 1}: 10,    //「myStruct{"A", 1}: 10」の省略記法
        {"B", 2}: 20,    //「myStruct{"B", 2}: 20」の省略記法
    }
    fmt.Println(map51[myStruct{"A", 1}], map51[myStruct{"B", 2}])

    // 要素の構造体に省略記法を使用する
    map52 := map[int]myStruct {
        10: {"A", 1},    //「10: myStruct{"A", 1}」の省略記法
        20: {"B", 2},    //「20: myStruct{"B", 2}」の省略記法
    }
    fmt.Println(map52[10], map52[20])
}

/**
 * -------------------------------------------------------
 * 11.2.6 マップのfor文
 * -------------------------------------------------------
 */
func example26() {
    // マップ型の変数宣言
    map61 := map[string]int{"a": 1, "b": 2, "c": 3, "d": 4}

    // マップのfor文: 1回目
    for k, e := range map61 {
        fmt.Print(k, ":", e, ",")
    }
    fmt.Println()

    // マップのfor文: 2回目 (ループ順序がランダムのため、1回目と同じにはならない)
    for k, e := range map61 {
        fmt.Print(k, ":", e, ",")
    }
    fmt.Println()

    // [値型と参照型]
    // Go言語の変数は、その型によって「値型」と「参照型」に大別されます。
    //
    // ・値型  ： 配列、構造体                    ( 値のコピーとなり、サイズが大きいほど性能面で影響が出る )
    // ・参照型： 文字列型、スライス型、マップ型  ( 参照のコピーのため、性能面での影響は少ない )
    //
    // 参照型とポインタの変数については、実体となる値を格納せず、参照やアドレスを格納する点でよく似ている。
    // どちらも値のサイズで性能面に影響しないため、参照型のアドレスを取得することは性能面で利点がありません。
    //
    // したがって、unsafeパッケージを使用する場合など特別な場合を除いて、参照型からアドレスを取得する操作は不要です。
    //
}
